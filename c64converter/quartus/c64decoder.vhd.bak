-- running on A-Video board Rev.2

library ieee;
use ieee.numeric_std.all;
use ieee.std_logic_1164.all;

entity C64Decoder is	
	port (
		-- input from the data aquisition
		CLKADC: in std_logic;
		LUMA: in std_logic_vector(7 downto 0);	
		CHROMA: in std_logic_vector(7 downto 0);
		
		-- output for further processing
		PIXEL: out boolean;   -- true if new data is ready
		HSYNC: out boolean;   -- true when beginning a new line
		VSYNC: out boolean;   -- true when beginning a new frame
		COLOR: out integer range 0 to 15;  -- C64 color

      -- debug info
		CHROMAANGLE: out integer range 0 ot 255
	);	
end entity;


architecture immediate of C64Converter is

	function atan2 (x:integer range -128 to 127; y:integer range -128 to 127) return integer 
	is 	
		variable xabs : integer range 0 to 127;
		variable yabs : integer range 0 to 127;		
		variable tmp : integer range 0 to 32767;
		variable scaled : integer range 0 to 255;
	begin 
		-- normalize to 1. quadrant
		if x>=0 then
			xabs := x;
		elsif x=-128 then
			xabs := 127;
		else
			xabs := -x;
		end if;
		if y>=0 then
			yabs := y;
		elsif y=-128 then
			yabs := 127;
		else
			yabs := -y;
		end if;
		
		-- calculate depending on octant	
		if xabs>=yabs then
			tmp := yabs;
			tmp := (tmp*256) / xabs;
		else
			tmp := xabs;
			tmp := (tmp*256) / yabs;
		end if;
		-- fake computation
		scaled := tmp;
		return scaled;
	end atan2;
	
begin		
		
	process (CLKADC)		
		type T_inv is array (0 to 63) of integer range 0 to 4095;
		constant inv : T_inv := (
			4095,4095,2048,1365,1024,819,683,585,
			512,455,410,372,341,315,293,273,
			256,241,228,216,205,195,186,178,
			171,164,158,152,146,141,137,132,
			128,124,120,117,114,111,108,105,
			102,100,98,95,93,91,89,87,
			85,84,82,80,79,77,76,74,
			73,72,71,69,68,67,66,65
		);		
	
	
		variable l_in : integer range 0 to 255 := 0;
		variable c_in : integer range 0 to 255 := 0;			
		variable c_prev : integer range 0 to 255 := 0;	
		
		variable x : integer range 0 to 63;
		variable xpositive : boolean;
		variable xd : integer range 0 to 63;
		variable xdpositive : boolean;
		
		variable slope : integer range 0 to 63;
		variable baseangle : integer range 0 to 255;
		variable use_negatively : boolean;
		
		variable angle : integer range 0 to 255;
	begin
	
		if rising_edge(CLKADC) then
			
			-- stage 4: calculate debug output levels			
			if use_negatively then 
				angle := baseangle - slope/2;
			else
				angle := baseangle + slope/2;
			end if;
			
			-- stage 3: compute x/xd slope values and prepare next computations
			slope := 0;
			use_negatively := false;
			if x=xd then
				if xpositive then 
					if xdpositive then baseangle:=32; else baseangle:=224; end if;
				else
					if xdpositive then baseangle:=96; else baseangle:=160; end if;
				end if;
			elsif x>xd then
				slope := (xd * inv(x)) / 64;
				if xpositive then 
					if xdpositive then baseangle:=0; else baseangle:=255; use_negatively:=true; end if;
				else
					if xdpositive then baseangle:=128; use_negatively:=true; else baseangle:=128; end if;
				end if;
			else
				slope := (x * inv(xd)) / 64;
				if xpositive then 
					if xdpositive then baseangle:=64; use_negatively:=true; else baseangle:=192; end if;
				else
					if xdpositive then baseangle:=64; else baseangle:=192; use_negatively:=true; end if;
				end if;
			end if;
						
			
			-- stage 2: compute and scale the x,xd values
			if c_in>=128 then 
				xpositive := true;
				x := (c_in-128) / 2;
			else
				xpositive := false;
				x := (128-c_in) / 2;
			end if;
			if c_in>=c_prev then 
				xdpositive := true;
				tmp := c_in-c_prev;
			else
				xdpositive := false;
				tmp := c_prev-c_in;
			end if;
			if tmp<=46 then
				xd := (tmp*11)/8;
			else	
				xd := 63;
			end if;
							
			-- stage 1: sample input data 
			l_in := to_integer(unsigned(LUMA));
			c_prev := c_in;
			c_in := to_integer(unsigned(CHROMA));			
		end if;
	
	
		-- output for further processing
		PIXEL <= false;
		HSYNC <= false;
		VSYNC <= false;
		COLOR <= 0;
		-- debug output
		CHROMAANGLE <= angle;	
	
	end process;	

end immediate;