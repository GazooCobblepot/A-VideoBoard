-- running on A-Video board Rev.2

library ieee;
use ieee.numeric_std.all;
use ieee.std_logic_1164.all;

entity C64Converter is	
	port (
--		-- reference clock
--		CLK25:  in std_logic;

		-- digital YPbPr output
		Y: out std_logic_vector(5 downto 0);
		Pb: out std_logic_vector(4 downto 0);
		Pr: out std_logic_vector(4 downto 0);

		-- input from the data aquisition
		CLKADC: in std_logic;
		LUMA: in std_logic_vector(7 downto 0);	
		CHROMA: in std_logic_vector(7 downto 0);
--		-- selection switches
--		GPIO2: in std_logic_vector(10 downto 3);

		TST : out std_logic
	);	
end entity;


architecture immediate of C64Converter is

   component C64Decoder is
	PORT
	(
		inclk0		: IN STD_LOGIC  := '0';
		c0		      : OUT STD_LOGIC; 
		c1		      : OUT STD_LOGIC 
	);
	end component;

	
begin		
		
	process (CLKADC)		
		type T_inv is array (0 to 63) of integer range 0 to 4095;
		constant inv : T_inv := (
			4095,4095,2048,1365,1024,819,683,585,
			512,455,410,372,341,315,293,273,
			256,241,228,216,205,195,186,178,
			171,164,158,152,146,141,137,132,
			128,124,120,117,114,111,108,105,
			102,100,98,95,93,91,89,87,
			85,84,82,80,79,77,76,74,
			73,72,71,69,68,67,66,65
		);		
	
	
		variable l_in : integer range 0 to 255 := 0;
		variable c_in : integer range 0 to 255 := 0;			
		variable c_prev : integer range 0 to 255 := 0;	
		
		variable x : integer range 0 to 63;
		variable xpositive : boolean;
		variable xd : integer range 0 to 63;
		variable xdpositive : boolean;
		
		variable slope : integer range 0 to 63;
		variable baseangle : integer range 0 to 255;
		variable use_negatively : boolean;
		
		variable angle : integer range 0 to 255;
      variable y_out : integer range 0 to 63 := 0;	
      variable pb_out : integer range 0 to 31 := 16;	
      variable pr_out : integer range 0 to 31 := 16;	
		
		variable tmp : integer range 0 to 127;
	begin
	
		if rising_edge(CLKADC) then
			
			-- stage 4: calculate debug output levels
         if l_in<50 then
				y_out := 0;
			elsif l_in<76 then
			   y_out := 32;
		   else
			   y_out := 32 + (l_in-76)/8;
			end if;
			
			if use_negatively then 
				angle := baseangle - slope/2;
			else
				angle := baseangle + slope/2;
			end if;
			pb_out := c_in / 8;  -- out of phase, but I don't care now
			
			pr_out := angle / 8;
			
			-- stage 3: compute x/xd slope values and prepare next computations
			slope := 0;
			use_negatively := false;
			if x=xd then
				if xpositive then 
					if xdpositive then baseangle:=32; else baseangle:=224; end if;
				else
					if xdpositive then baseangle:=96; else baseangle:=160; end if;
				end if;
			elsif x>xd then
				slope := (xd * inv(x)) / 64;
				if xpositive then 
					if xdpositive then baseangle:=0; else baseangle:=255; use_negatively:=true; end if;
				else
					if xdpositive then baseangle:=128; use_negatively:=true; else baseangle:=128; end if;
				end if;
			else
				slope := (x * inv(xd)) / 64;
				if xpositive then 
					if xdpositive then baseangle:=64; use_negatively:=true; else baseangle:=192; end if;
				else
					if xdpositive then baseangle:=64; else baseangle:=192; use_negatively:=true; end if;
				end if;
			end if;
						
			
			-- stage 2: compute and scale the x,xd values
			if c_in>=128 then 
				xpositive := true;
				x := (c_in-128) / 2;
			else
				xpositive := false;
				x := (128-c_in) / 2;
			end if;
			if c_in>=c_prev then 
				xdpositive := true;
				tmp := c_in-c_prev;
			else
				xdpositive := false;
				tmp := c_prev-c_in;
			end if;
			if tmp<=46 then
				xd := (tmp*11)/8;
			else	
				xd := 63;
			end if;
							
			-- stage 1: sample input data 
			l_in := to_integer(unsigned(LUMA));
			c_prev := c_in;
			c_in := to_integer(unsigned(CHROMA));			
		end if;
	
      y <= std_logic_vector(to_unsigned(y_out,6));
      pb <= std_logic_vector(to_unsigned(pb_out,5));
      pr <= std_logic_vector(to_unsigned(pr_out,5));
		
--		if cnt>=8 then
--			tst <= '1';
--		else
--			tst <= '0';
--		end if;
--      tst <= CHROMA(7);
      tst <= '0';	    
	
	end process;	

end immediate;